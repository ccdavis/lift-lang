use crate::syntax::{Operator,DataType,Param,KeywordArg,Expr, Function, LiteralData, KeyData};

grammar;

// Skip whitespace and comments
match {
    r"\s*" => { }, // Skip whitespace
    r"//[^\n\r]*[\n\r]*" => { }, // Skip line comments
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { }, // Skip block comments
} else {
    _ // Everything else
}

// A complete program is a sequence of top-level expressions
pub Program: Expr = {
    <s:SemiSeparated<ProgramPartExpr>> => Expr::Program {body:s, environment: 0}.into(),  
};

pub ProgramPartExpr: Expr = {
    ExprBlock,
    ExprType,
    ExprOutput,
    ExprLen,
    ExprIf,
    ExprWhile,
    ExprLet,
    ExprDefineFunction,
    ExprLambda,
    ExprAssign,
}


ExprOutput: Expr =  {
    "output(" <o:CommaSeparated<ProgramPartExpr>> ")" => Expr::Output { data: o}.into(),
}

ExprLen: Expr = {
    "len(" <e:ProgramPartExpr> ")" => Expr::Len { expr: Box::new(e) }.into(),
}

ExprBlock: Expr = {
  "{" <s:SemiSeparated<ProgramPartExpr>>   "}" => Expr::Block {body:s, environment: 0}.into(),  
};

ExprType: Expr = {
    "type" <i:ident> "="  <d:DataType> => Expr::DefineType {type_name: i,definition: d,index: (0,0)}.into(),
    "type" <i:ident> "=" <n:int> "to"  <m:int> =>  Expr::DefineType {type_name: i,index: (0,0), definition: DataType::Range(Box::new(Expr::Range(n.into(),m.into())))}.into(),
    "type" <i:ident> "=" <n:str> "to"  <m:str> =>  Expr::DefineType {type_name: i,index: (0,0), definition: DataType::Range(Box::new(Expr::Range(n.into(),m.into())))}.into(),
    "type" <i:ident> "="  "List" "of" <d:DataType> => Expr::DefineType {type_name: i,definition: DataType::List {element_type: Box::new(d)},index: (0,0)}.into(),
    "type" <i:ident> "=" "Map" "of" <k:DataType> "to" <v:DataType> => Expr::DefineType {type_name: i,definition: DataType::Map {key_type: Box::new(k), value_type: Box::new(v)},index: (0,0)}.into(),
    "type" <i:ident> "=" "Set" "of" <d:DataType> => Expr::DefineType { type_name: i, definition: DataType::Set(Box::new(d)), index: (0,0)},
    "type" <i:ident> "=" "(" <e:CommaSeparated<ident>> ")"=> Expr::DefineType {type_name: i, definition: DataType::Enum(e), index: (0,0)},
    "type" <i:ident> "=" "struct"  "(" <m:CommaSeparated<Param>> ")" =>Expr::DefineType{type_name: i,definition: DataType::Struct(m), index: (0,0)},
};

ExprLet: Expr= {
    "let" <n: ident> "=" <r:ProgramPartExpr> => Expr::Let {var_name: n, data_type: DataType::Unsolved, index: (0,0), value: Box::new(r), mutable: false}.into(),
    "let" <n: ident>":" <d:DataType>  "=" <r:ProgramPartExpr> => Expr::Let {var_name: n, data_type: d, index: (0,0), value: Box::new(r), mutable: false}.into(),
    "let" "var" <n: ident> "=" <r:ProgramPartExpr> => Expr::Let {var_name: n, data_type: DataType::Unsolved, index: (0,0), value: Box::new(r), mutable: true}.into(),
    "let" "var" <n: ident>":" <d:DataType>  "=" <r:ProgramPartExpr> => Expr::Let {var_name: n, data_type: d, index: (0,0), value: Box::new(r), mutable: true}.into(),
};

ExprIf: Expr = "if" <cond:ExprLogicOr> <then_block:ExprBlock> <else_part:ElsePart> => {
    Expr::If {
        cond: Box::new(cond), 
        then: Box::new(then_block), 
        final_else: Box::new(else_part)
    }.into()
};

ElsePart: Expr = {
    "else" "if" <cond:ExprLogicOr> <then_block:ExprBlock> <else_part:ElsePart> => {
        Expr::If {
            cond: Box::new(cond),
            then: Box::new(then_block),
            final_else: Box::new(else_part)
        }
    },
    "else" <block:ExprBlock> => block,
    // Optional else - if no else is provided, return Unit
    () => Expr::Unit,
};
ExprWhile: Expr =  "while" <c:ExprLogicOr> <b:ExprBlock> => Expr::While { cond: Box::new(c), body: Box::new(b)}.into();
ExprDefineFunction: Expr  = {
    // Regular function: function name(...)
    "function" <n: ident>  <f:DefFunction> => Expr::DefineFunction {fn_name: n, index: (0,0), value: Box::new(f)}.into(),
    // Method function: function Type.name(...)
    "function" <t: TypeName> "." <n: ident> <f:MethodDefFunction> => {
        let mut func_expr = f;
        if let Expr::Lambda { ref mut value, .. } = func_expr {
            value.receiver_type = Some(t.clone());
        }
        Expr::DefineFunction {fn_name: format!("{}.{}", t, n), index: (0,0), value: Box::new(func_expr)}.into()
    },
};
ExprLambda: Expr = "Lambda" <f:LambdaFunction> => Expr::Lambda { value: f, environment: 0}.into();

DefFunction: Expr = "(" <pm:CommaSeparated<Param>> ")" ":" <rt:DataType> <b:ExprBlock> => Expr::Lambda { value: Function { body: Box::new(b), params: pm, return_type: rt, receiver_type: None, builtin: None}, environment: 0}.into();
MethodDefFunction: Expr = "(" <pm:CommaSeparated<Param>> ")" ":" <rt:DataType> <b:ExprBlock> => Expr::Lambda { value: Function { body: Box::new(b), params: pm, return_type: rt, receiver_type: None, builtin: None}, environment: 0}.into();
LambdaFunction: Function = "(" <lpm:CommaSeparated<Param>> ")"  ":" <dt:DataType> <b:ExprBlock> => Function { params: lpm, body: Box::new(b), return_type: dt, receiver_type: None, builtin: None };  
  
ExprAssign = {
    //DiscardResult,
    AssignResult,
    ExprLogicOr,
};

AssignResult: Expr  = {
    // Simple variable assignment
    <v:ident> ":=" <p:ProgramPartExpr> => Expr::Assign { name: v.to_string(), value: Box::new(p), index: (0,0)}.into(),
    // Field assignment: expr.field := value
    <e:Postfix> "." <field:ident> ":=" <p:ProgramPartExpr> => Expr::FieldAssign {
        expr: Box::new(e),
        field_name: field,
        value: Box::new(p),
        index: (0, 0)
    }.into(),
};

//DiscardResult: Expr = {
//    "!" <p:ProgramPartExpr> ";" =>  p.into(),
//};

ExprLogicOr = ExprInfix<ExprLogicOr, OpLogicOr, ExprLogicAnd>;
OpLogicOr: Operator = "or" => Operator::Or;
ExprLogicAnd = ExprInfix<ExprLogicAnd, OpLogicAnd, ExprLogicNot>;
OpLogicAnd: Operator = "and" => Operator::And;

ExprLogicNot: Expr = {
    "not" <e:ExprLogicNot> => Expr::UnaryExpr { op: Operator::Not, expr: Box::new(e) },
    ExprEquality,
};

ExprEquality = ExprInfix<ExprEquality, OpEquality, ExprComparison>;

OpEquality: Operator = {
    "=" => Operator::Eq,
    "<>" => Operator::Neq,
}

ExprComparison = ExprInfix<ExprComparison, OpComparison, ExprRange>;
OpComparison: Operator = {
    ">" => Operator::Gt,
    ">=" => Operator::Gte,
    "<" => Operator::Lt,
    "<=" => Operator::Lte,    
}

// Range expressions have lower precedence than arithmetic
ExprRange: Expr = {
    <l:ExprArithmetic> ".." <r:ExprArithmetic> => {
        // For now, we'll create a BinaryExpr with a special Range operator
        // This will be handled properly in the interpreter
        Expr::BinaryExpr {
            left: Box::new(l),
            op: Operator::Range,
            right: Box::new(r),
        }
    },
    ExprArithmetic,
}


ExprArithmetic: Expr = {	      
    <l:ExprArithmetic> "+" <r:Factor> => Expr::add(l, r).into(),
    <l:ExprArithmetic> "-" <r:Factor> => Expr::sub(l, r).into(),
    Factor,
};

SemiSeparated<T>: Vec<T> = { 
    <s:(<T> ";")*> <e:T?> => match e {
        None => s,
        Some(e) => {
            let mut s = s;
            s.push(e);
            s
        }
    }
};


Factor: Expr = {
    <l:Factor> "*" <r:Term> => Expr::mul(l, r).into(),
    <l:Factor> "/" <r:Term> => Expr::div(l, r).into(),
    Term,
};

Term: Expr = {
    Postfix,
    "-" <t:Term> => {
        match &t {
            Expr::Literal(LiteralData::Int(n)) => Expr::Literal(LiteralData::Int(-n)),
            Expr::Literal(LiteralData::Flt(f)) => Expr::Literal(LiteralData::Flt(-f)),
            _ => Expr::sub(Expr::Literal(LiteralData::Int(0)), t),
        }
    },
};

Postfix: Expr = {
    <e:Postfix> "[" <i:ProgramPartExpr> "]" => Expr::Index { expr: Box::new(e), index: Box::new(i) },
    <e:Postfix> "." <method:ident> "(" <args:CommaSeparated<KeywordArg>> ")" => Expr::MethodCall {
        receiver: Box::new(e),
        method_name: method,
        fn_index: (0, 0),
        args
    },
    <e:Postfix> "." <field:ident> => Expr::FieldAccess {
        expr: Box::new(e),
        field_name: field,
    },
    Atom,
};

Atom: Expr = {
    "(" <e:ProgramPartExpr> ")" => e,
    LiteralData => Expr::Literal(<>),
    "[" <elements:CommaSeparated<ProgramPartExpr>> "]" => {
        Expr::ListLiteral {
            data_type: DataType::Unsolved,
            data: elements,
        }
    },
    "#" "{" <pairs:CommaSeparated<MapPair>> "}" => {
        Expr::MapLiteral {
            key_type: DataType::Unsolved,
            value_type: DataType::Unsolved,
            data: pairs,
        }
    },
    // Function call or struct literal: name(arg: value, ...)
    // We parse both as Call here; semantic analysis will convert to StructLiteral if name is a type
    <i:ident> "(" <a:CommaSeparated<KeywordArg>> ")" => Expr::Call{ fn_name:i, args: a, index: (0,0)},
    <v:ident> => Expr::Variable { name:v.to_string(), index: (0,0)},
};

KeywordArg: KeywordArg = {
	<k:ident> ":" <e:ProgramPartExpr> => KeywordArg { name: k.to_string(),value: e},
}

MapPair: (KeyData, Expr) = {
    <k:LiteralData> ":" <v:ProgramPartExpr> => {
        match k {
            LiteralData::Int(i) => (KeyData::Int(i), v),
            LiteralData::Str(s) => (KeyData::Str(s), v),
            LiteralData::Bool(b) => (KeyData::Bool(b), v),
            LiteralData::Flt(_) => panic!("Float keys are not supported in maps"),
        }
    },
}

Param:  Param = {
    <p:ident> ":" <t:DataType> => Param { name: p.to_string(), data_type: t, default: None, index: (0,0), copy: false},
    "cpy" <p:ident> ":" <t:DataType> => Param { name: p.to_string(), data_type: t, default: None, index: (0,0), copy: true},
}

pub DataType : DataType = {
    "Int" => DataType::Int,
    "Flt" => DataType::Flt,
    "Str" => DataType::Str,
    "Bool" => DataType::Bool,
    "List of" <e: DataType> => DataType::List { element_type: Box::new(e)},
    "Map of" <k: DataType> "to" <v: DataType> => DataType::Map { key_type: Box::new(k), value_type: Box::new(v)},
    <i:ident> => DataType::TypeRef(i), // Custom type reference
};

CommaSeparated<T>: Vec<T> = { 
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};


pub LiteralData: LiteralData = {
    int => LiteralData::from(<>),
    flt => LiteralData::from(<>),
    str => LiteralData::from(<>),
    bool => LiteralData::from(<>),  
};

flt: f64 = {
  <s:r"[0-9]+\.[0-9]+"> => s.parse().unwrap(),
};

str: String= {  
  <i:r"'([^'])*'"> => i.to_string(),
};

int: i64 = {
  <s:r"[0-9]+"> => s.parse().unwrap(),
};

bool: bool = {
  "true" => true,
  "false" => false,
};

ident: String = {
  <i:r"[a-zA-Z][a-zA-Z0-9_-]*"> => i.to_string(),
};

TypeName: String = {
    "Str" => "Str".to_string(),
    "Int" => "Int".to_string(),
    "Flt" => "Flt".to_string(),
    "Bool" => "Bool".to_string(),
    "List" => "List".to_string(),
    "Map" => "Map".to_string(),
    "Range" => "Range".to_string(),
    <i:ident> => i,
};

ExprInfix<Lt, Op, Rt>: Expr = {
    <lt:Lt> <op:Op> <rt:Rt> =>
        Expr::BinaryExpr { left: Box::new(lt), op, right: Box::new(rt)} ,
    Rt,
}

